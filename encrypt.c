#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <time.h>

#include "encrypt.h"

/* Generates random 64-bit key by concatenating 8 randomly generated bytes */
uint64_t generate_rand_key64() {
	int i;
	uint64_t* key_val;
	char key[BLOCK_SIZE_IN_BYTES];

	key_val = NULL;

	// Initialize RNG with system time as seed
	srand(time(0));

	for(i = 0; i < BLOCK_SIZE_IN_BYTES; i++)
		key[i] = rand() % 128; // get a random unsigned 8-bit number

	key_val = (uint64_t*)key;

	return *key_val;
}

/* Pads plain_text buffer with null bytes so the size is a multiple of the block size */
void pad_plaintext_buf(plain_text* ptx) {
	int i;
	long num_bytes_rem;

	/* For this example, BLOCK_SIZE = 64 bits = 8 bytes, so the size needs to be a multiple of 8 bytes (or 64 bits)
	* n = size of buf (in bytes)
	* Need to do c = n / 8, if c is a decimal, need to round up.
	* Then do num_bytes_rem = c * 8 - n, which will give the number of bytes to pad on
	* c = 125 / 8 = 15.625, round up to 16
	* Ex. assume text is n = 125 bytes
	* num_bytes_rem = c*8 - n = 16*8 - 125 = 128 - 125 = 3
	*/

	num_bytes_rem = (int)CEIL(ptx->size_in_bytes, BLOCK_SIZE_IN_BYTES) * BLOCK_SIZE_IN_BYTES -  ptx->size_in_bytes;

	ptx->ptx_buf = (char*)realloc(ptx->ptx_buf, ptx->size_in_bytes + num_bytes_rem);
	ptx->size_in_bytes += num_bytes_rem;

	for (i = 1; i <= num_bytes_rem; i++)
		ptx->ptx_buf[ptx->size_in_bytes - i] = '\0';

}

/* Encrypts input buffer each block (64-bit) at a time by adding a 64 bit key to each block.
 * If decrypting, (bool encrypt = false), decrypts by subtracting key instead
 */
cipher_text* encrypt_decrypt(const char* buf, size_t buf_size_in_bytes, uint64_t key, bool encrypt){
	int i;
	long num_blocks;
	uint64_t* block_val;
	uint64_t* cipher_val;
	uint64_t val;
	cipher_text* ctx;
	char* tmp_ctx_buf;

	block_val = NULL;
	cipher_val = NULL;

	num_blocks = buf_size_in_bytes / BLOCK_SIZE_IN_BYTES;

	cipher_val = &val;

	ctx = (cipher_text*)malloc(sizeof(cipher_text));
	ctx->ctx_buf = (char*)malloc(sizeof(char)*buf_size_in_bytes);
	ctx->size_in_bytes = buf_size_in_bytes;

	tmp_ctx_buf = ctx->ctx_buf;

	for (i = 0; i < num_blocks; i++){
		block_val = (uint64_t*)buf;

		if(encrypt)
			val = *block_val + key;
		else
			val = *block_val - key;

		memcpy(tmp_ctx_buf, (char*)cipher_val, BLOCK_SIZE_IN_BYTES);

		// Move pointers to copy next 64 bit block (by 8 bytes/chars)
		buf += BLOCK_SIZE_IN_BYTES;
		tmp_ctx_buf += BLOCK_SIZE_IN_BYTES;
	}

	return ctx;
}

cipher_text* encrypt(plain_text* ptx, uint64_t key){
	pad_plaintext_buf(ptx);
	return encrypt_decrypt((const char*)ptx->ptx_buf, ptx->size_in_bytes, key, 1);
}

plain_text* decrypt(cipher_text* ctx, uint64_t key){
	return (plain_text*)encrypt_decrypt((const char*)ctx->ctx_buf, ctx->size_in_bytes, key, 0);
}
